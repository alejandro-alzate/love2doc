<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
	<link rel="self" type="application/atom+xml" href="https://love2d.org/forums/app.php/feed/topic/94380" />

	<title>LÖVE</title>
	
	<link href="https://love2d.org/forums/index.php" />
	<updated>2024-03-25T13:02:45+00:00</updated>

	<author><name><![CDATA[LÖVE]]></name></author>
	<id>https://love2d.org/forums/app.php/feed/topic/94380</id>

		<entry>
		<author><name><![CDATA[Trystan]]></name></author>
		<updated>2024-03-25T13:02:45+00:00</updated>

		<published>2024-03-25T13:02:45+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=259114#p259114</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=259114#p259114"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=259114#p259114"><![CDATA[
I was thinking about dithing the other day and played around with the idea of error being pushed to the right and downwards through a maze (where the mazes passability allows it).<br><div class="inline-attachment"><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=24114&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=24114" class="postimage" alt="CurveDither.png" /></a></dt></dl></div>The attached uses this for a few different wall layouts, "t" toggles showing the layout on the left picture:<br>F1 - All walls on (no error is passed so this is just quantizing each pixel to black and white based on the threshold)<br>F2 - All walls cleared, error is free to go down and right forever<br>F3 - Random walls<br>F4 - Walls generated by a maze algorithm (for both this and random "a" toggles animation)<br>F5 - Error is pushed along the path of a Hilbert Curve (starting in the bottom left)<br>F6 - Generates the Hilbert Curve but error is pushed down and right from the top left as with the other layouts.<br><br>It generates some fun results but nothing that to my eye looks any better than the faster methods above. There is room though for trying different curves/layouts, changing how you loop through the grid and where you push error to and maybe pushing the error further to spread it over more cells<br><br>The main code is here:<div class="codebox"><p>Code: </p><pre><code>-- https://en.wikipedia.org/wiki/Space-filling_curve-- https://en.wikipedia.org/wiki/Maze_generation_algorithm-- Disable output buffer so debug messages print in real timeio.stdout:setvbuf("no")function love.load()    bit = require "bit"    math.randomseed(os.time())    math.random(); math.random(); math.random()    love.window.setTitle("Space-filling curve Dithering")    love.graphics.setDefaultFilter("nearest", "nearest", 1)    imgData = love.image.newImageData("David.png")    origImg = love.graphics.newImage(imgData)    scale = 6    imgSize = imgData:getWidth()    love.window.setMode(imgSize * scale * 2, imgSize * scale)    threshold = 0.5 -- The threshold for seperating white and black pixels    drawGridToggle = false    animateDither = true    animationDelay = 20    timer = 0    currentCurve = setWallsZero    currentCurve()endfunction love.keypressed(key)    if key == "f1" then        currentCurve = setWallsZero        currentCurve()    end    if key == "f2" then        currentCurve = setWallsMax        currentCurve()    end    if key == "f3" then        currentCurve = setWallsRandom        currentCurve()    end    if key == "f4" then        currentCurve = setWallsBacktracker        currentCurve()    end    if key == "f5" then        currentCurve = setWallsHilbertFollow        currentCurve()    end    if key == "f6" then        currentCurve = setWallsHilbert        currentCurve()    end    if key == "t" then        drawGridToggle = not drawGridToggle    end    if key == "a" then        animateDither = not animateDither    end    if key == "escape" then        love.event.quit()    endendfunction resetCellGrid()    -- cellGrid will hold a number of allowed directions, 1 = up, 2 = right, 4 = down, 8 = left    -- 0 is unvisited    -- the second entry is the red from our picture, reset this each run as we mess with cellGrid when dithering    cellGrid = {}    for x = 0, imgSize - 1 do        cellGrid[x] = {}        for y = 0, imgSize - 1 do            cellGrid[x][y] = {0, imgData:getPixel(x, y)}        end    endendfunction setWallsZero()    resetCellGrid()    -- set no passability, essentialy threshold shading    for x = 0, imgSize - 1 do        for y = 0, imgSize - 1 do            cellGrid[x][y][1] = 0        end    end    if ditheredImg then ditheredImg:release() end    ditheredImg = applyDither()endfunction setWallsMax()    resetCellGrid()    -- set all passability, allowing error to travel forever    for x = 0, imgSize - 1 do        for y = 0, imgSize - 1 do            cellGrid[x][y][1] = 15            if x == imgSize - 1 then                cellGrid[x][y][1] = bit.band(cellGrid[x][y][1], 13)            end            if y == imgSize - 1 then                cellGrid[x][y][1] = bit.band(cellGrid[x][y][1], 11)            end        end    end    if ditheredImg then ditheredImg:release() end    ditheredImg = applyDither()endfunction setWallsRandom()    resetCellGrid()    -- set passability randomly, block off last row and column    for x = 0, imgSize - 1 do        for y = 0, imgSize - 1 do            cellGrid[x][y][1] = math.random(16)            if x == imgSize - 1 then                cellGrid[x][y][1] = bit.band(cellGrid[x][y][1], 13)            end            if y == imgSize - 1 then                cellGrid[x][y][1] = bit.band(cellGrid[x][y][1], 11)            end        end    end    if ditheredImg then ditheredImg:release() end    ditheredImg = applyDither()endfunction setWallsBacktracker()    resetCellGrid()    -- set passability with a recursive backtracker    local currX, currY = 0, 0    local neighbours, r, dir    local stack = {{currX, currY}}    while #stack &gt; 0 do        -- get neightbours        neighbours = getNeighbours(currX, currY)        if #neighbours == 0 then            -- we have no eligible neighbours, step back            table.remove(stack)            if #stack &gt; 0 then                currX, currY = stack[#stack][1], stack[#stack][2]            end        else            -- we have neighbours, get a random one            r = math.random(#neighbours)            dir = neighbours[r][3]            -- set our exit            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], dir)            -- set new current            currX = neighbours[r][1]            currY = neighbours[r][2]            table.insert(stack, {currX, currY})            -- set our entry            if dir == 1 then                dir = 4            elseif dir == 2 then                dir = 8            elseif dir == 4 then                dir = 1            else                dir = 2            end            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], dir)        end    end    if ditheredImg then ditheredImg:release() end    ditheredImg = applyDither()endfunction setWallsHilbert()    resetCellGrid()    if ditheredImg then ditheredImg:release() end    local hText = require "hilbert"    local dir = 2    local currX, currY = 0, 127    local char    for i = 1, #hText do        char = hText:sub(i, i)        if char == "-" then            -- turn left            dir = dir / 2            if dir &lt; 1 then dir = 8 end        elseif char == "+" then            -- turn right            dir = dir * 2            if dir &gt; 8 then dir = 1 end        end        --move forwards        cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], dir)        col = cellGrid[currX][currY][2]        if dir == 1 then            currY = currY - 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 4)        elseif dir == 2 then            currX = currX + 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 8)        elseif dir == 4 then            currY = currY + 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 1)        else            currX = currX - 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 2)        end    end    if ditheredImg then ditheredImg:release() end    ditheredImg = applyDither()endfunction setWallsHilbertFollow()    resetCellGrid()    if ditheredImg then ditheredImg:release() end    local col, err    local newImgData = love.image.newImageData(imgSize, imgSize)    local hText = require "hilbert"    local dir = 2    local currX, currY = 0, 127    local char    for i = 1, #hText do        char = hText:sub(i, i)        if char == "-" then            -- turn left            dir = dir / 2            if dir &lt; 1 then dir = 8 end        elseif char == "+" then            -- turn right            dir = dir * 2            if dir &gt; 8 then dir = 1 end        end        --move forwards        cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], dir)        col = cellGrid[currX][currY][2]        -- set cell and get error        if col &lt; threshold then            err = col            col = 0        else            err = col - 1            col = 1        end        -- draw pixel        newImgData:setPixel(currX, currY, col, col, col, 1)        if dir == 1 then            currY = currY - 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 4)        elseif dir == 2 then            currX = currX + 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 8)        elseif dir == 4 then            currY = currY + 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 1)        else            currX = currX - 1            cellGrid[currX][currY][1] = bit.bor(cellGrid[currX][currY][1], 2)        end        -- push error        cellGrid[currX][currY][2] = cellGrid[currX][currY][2] + err    end    ditheredImg = love.graphics.newImage(newImgData)endfunction getNeighbours(x, y)    local neighbours = {}    -- up    if y &gt; 0 then        if cellGrid[x][y - 1][1] == 0 then            table.insert(neighbours, {x, y - 1, 1})        end    end    -- right    if x &lt; imgSize - 1 then        if cellGrid[x + 1][y][1] == 0 then            table.insert(neighbours, {x + 1, y, 2})        end    end    -- down    if y &lt; imgSize - 1 then        if cellGrid[x][y + 1][1] == 0 then            table.insert(neighbours, {x, y + 1, 4})        end    end    -- left    if x &gt; 0 then        if cellGrid[x - 1][y][1] == 0 then            table.insert(neighbours, {x - 1, y, 8})        end    end    return neighboursendfunction applyDither()    local col, err, val    local newImgData = love.image.newImageData(imgSize, imgSize)    for x = 0, imgSize - 1 do        for y = 0, imgSize - 1 do            val = cellGrid[x][y][1]            col = cellGrid[x][y][2]            -- set cell and get error            if col &lt; threshold then                err = col                col = 0            else                err = col - 1                col = 1            end            -- get neighbours to pass error            -- both            if bit.band(val, 6) == 6 then                err = err / 2                cellGrid[x + 1][y][2] = cellGrid[x + 1][y][2] + err                cellGrid[x][y + 1][2] = cellGrid[x][y + 1][2] + err            -- right            elseif bit.band(val, 2) == 2 then                cellGrid[x + 1][y][2] = cellGrid[x + 1][y][2] + err            -- down            elseif bit.band(val, 4) == 4 then                cellGrid[x][y + 1][2] = cellGrid[x][y + 1][2] + err            end            -- set the image data            newImgData:setPixel(x, y, col, col, col, 1)        end    end    return love.graphics.newImage(newImgData)endfunction drawGrid()    -- draw grid, only need to draw right and down    local val    love.graphics.setLineWidth(1 / scale)    for x = 0, imgSize - 1 do        for y = 0, imgSize - 1 do            val = cellGrid[x][y][1]            -- check if we are blocked right            if bit.band(val, 2) == 0 then                love.graphics.line(x + 1, y, x + 1, y + 1)            end            -- check if we are blocked down            if bit.band(val, 4) == 0 then                love.graphics.line(x, y + 1, x + 1, y + 1)            end        end    endendfunction love.update(dt)    timer = timer + 1    if timer % animationDelay == 0 and animateDither then        currentCurve()    endendfunction love.draw()    local start = love.timer.getTime()    love.graphics.push()    love.graphics.scale(scale)    love.graphics.draw(origImg)    if drawGridToggle == true then        love.graphics.setColor(0.2, 0.4, 0.8)        drawGrid()        love.graphics.setColor(1, 1, 1)    end    love.graphics.draw(ditheredImg, imgSize, 0)    love.graphics.pop()    -- ui    love.graphics.print([[F1 - All walls blockedF2 - All walls openF3 - Random wallsF4 - Recursive backtracker mazeF5 - Hilbert Curve (following curve)F6 - Hilbert Curve (from top left)T - Toggle gridA - Toggle animation]], 5, 5)end</code></pre></div>The love file is attached which includes my test image and the export from a L-System program I was using to quickly generate the Hilbert curve (probably not the best way to do it but it was fast to implement with what I already had)<dl class="file"><dt><img src="./images/upload_icons/love.png" alt="" /> <a class="postlink" href="https://love2d.org/forums/download/file.php?id=24112">CurveDither.love</a></dt></dl><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=257841">Trystan</a> — Mon Mar 25, 2024 1:02 pm</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[Trystan]]></name></author>
		<updated>2024-02-27T09:59:48+00:00</updated>

		<published>2024-02-27T09:59:48+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=258842#p258842</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=258842#p258842"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=258842#p258842"><![CDATA[
I was playing around with Dithering the other day and thought I'd add my script here. It's nothing that hasn't been done (better) above but it was fun to create.<br><br>There are a few different dithers and colour reduction methods you can do by changing the arguments of the dither function. My dither matrices are stored in a kind of unusual way, instead of being a proper matrix they're a table of tables with an xoffset, yoffset and then the proportion of error to be diffused to that position.<br><br>I had used this originally to dither images for pico-8 that could then be loaded directly to vram from a string so there are a few lines commented out that create that string and print it to the console, I don't reccomend turning them on for a large image, they're very slow.<br><br>Finally, depending on the size of the picture you're doing you will need to change the "scale" variable. I could have made it autoadjust but didn't really feel that was necessary for what I wanted it to do.<br><br>Dithering to the pico-8 palette (Floyd-Steinberg)<div class="inline-attachment"><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=24036&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=24036" class="postimage" alt="Dither 442.png" /></a></dt></dl></div>Dithering to 5 bit colour (4 values of red, 4 of green, 2 of blue) (Floyd-Steinberg)<div class="inline-attachment"><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=24037&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=24037" class="postimage" alt="Dither Pico8.png" /></a></dt></dl></div>The pico-8 code I was using to load an image was simply the below that replaces everything in vram with the contents of a string. Note, this string could be a lot shorter with some simple RLE but I was just wanting to see something on screen.<div class="codebox"><p>Code: </p><pre><code>function _init() imgstr="[paste string here]" loadpic(imgstr) palt(0,false)endfunction loadpic(imgstr) for i=1,#imgstr,2 do  local n1=tonum(imgstr[i],0x1)  local n2=tonum(imgstr[i+1],0x1)  poke(0x6000+(i-1)/2,n2*16+n1) endendfunction _update()endfunction _draw()end</code></pre></div>And this is the love2d file for doing the dithering:<div class="codebox"><p>Code: </p><pre><code>-- Disable output buffer so debug messages print in real timeio.stdout:setvbuf("no")function love.load()    love.graphics.setDefaultFilter("nearest", "nearest", 1)    love.window.setMode(1536, 768)    love.window.setTitle("Error Diffusion Dithering")    scale = 6 -- scale to draw the result at    imgPath = "Images/Rainbow128.jpg" -- image to use    -- pico-8 palette for paletted quantizing    pal = {}    pal.Pico8 = {        {29/255, 43/255, 83/255},        {126/255, 37/255, 83/255},        {0/255, 135/255, 81/255},        {171/255, 82/255, 54/255},        {95/255, 87/255, 79/255},        {194/255, 195/255, 199/255},        {255/255, 241/255, 232/255},        {255/255, 0/255, 77/255},        {255/255, 163/255, 0/255},        {255/255, 236/255, 39/255},        {0/255, 228/255, 54/255},        {41/255, 173/255, 255/255},        {131/255, 118/255, 156/255},        {255/255, 119/255, 168/255},        {255/255, 204/255, 170/255},        {0/255, 0/255, 0/255},    }    palStr = ""    -- Setup dither matrices matrix, each is a table of {xoff, yoff, proportion of error to give}    dMat = {}    dMat.FloydSteinberg = {        { 1, 0, 7/16},        {-1, 1, 3/16},        { 0, 1, 5/16},        { 1, 1, 1/16},    }    dMat.Atkinson = {        { 1, 0, 1/8},        { 2, 0, 1/8},        {-1, 1, 1/8},        { 0, 1, 1/8},        { 1, 1, 1/8},        { 0, 2, 1/8},    }    dMat.JarvisJudiceNinke = {        { 1, 0, 7/48},        { 2, 0, 5/48},        {-2, 1, 3/48},        {-1, 1, 5/48},        { 0, 1, 7/48},        { 1, 1, 5/48},        { 2, 1, 3/48},        {-2, 2, 1/48},        {-1, 2, 3/48},        { 0, 2, 5/48},        { 1, 2, 3/48},        { 2, 2, 1/48},    }    dMat.None = {}    local originalData = love.image.newImageData(imgPath)    originalImg = love.graphics.newImage(originalData)    --transformedImg = dither(originalData, quantPalette, pal.Pico8, false, dMat.FloydSteinberg)    transformedImg = dither(originalData, quantReduce, {4, 4, 2}, false, dMat.FloydSteinberg)endfunction quantReduce(r, g, b, valuesPerColour)    local lr, lg, lb    if type(valuesPerColour) == "table" then        -- we have a table, set levels seperately        lr, lg, lb = valuesPerColour[1], valuesPerColour[2], valuesPerColour[3]    else        -- we have a number, set all the same        lr, lg, lb = valuesPerColour, valuesPerColour, valuesPerColour    end    r = math.floor(r * (lr - 0.5)) / (lr - 1)    g = math.floor(g * (lg - 0.5)) / (lg - 1)    b = math.floor(b * (lb - 0.5)) / (lb - 1)    return r, g, bendfunction quantPalette(r, g, b, pal)    local dist, bestInd, bestDist    bestDist = 1000    for i = 1, #pal do        dist = math.abs(r - pal[i][1]) + math.abs(g - pal[i][2]) + math.abs(b - pal[i][3])        if dist &lt; bestDist then            bestDist = dist            bestInd = i        end    end    -- uncomment to add the char to the palette string    -- palStr = palStr .. string.format("%x", bestInd % 16)    return pal[bestInd][1], pal[bestInd][2], pal[bestInd][3]end-- Dithers an imageData. 2nd argument is the quantization function (quantReduce to reduce colour bit depth and quantPalette to match to a palette). -- quantArg is a number of values per colour for reduce (or a table of 3 like {8, 8, 4} for classic 8-bit reduction). -- quantArg is a palette table of colours for the palette. Greyscale sets if the image should be turned greyscale first. ditherMatric sets the matric to use.function dither(data, quantFunc, quantArg, greyscale, ditherMatrix)    local r, g, b, er, eg, eb, val, tx, ty    local height = data:getHeight() - 1    local width = data:getWidth() - 1    -- loop through all pixels, with x as inner loop    for y = 0, height do        for x = 0, width do            -- get pixel            r, g, b = data:getPixel(x, y)            if greyscale then                -- make greyscale                val = (0.299 * r) + (0.587 * g) + (0.114 * b)                r = val; g = val; b = val            end            -- backup r, g, b for working out the error later            er, eg, eb = r, g, b            -- quantize            r, g, b = quantFunc(r, g, b, quantArg)            data:setPixel(x, y, r, g, b, 1)            -- get difference from original pixel (error)            er = er - r            eg = eg - g            eb = eb - b            -- pass error on to neighbours            for i = 1, #ditherMatrix do                tx = x + ditherMatrix[i][1]                ty = y + ditherMatrix[i][2]                -- check it's in bounds, we don't need to check ty &gt; 0 though, we never pass error up                if tx &gt; 0 and tx &lt; width and ty &lt; height then                    r, g, b = data:getPixel(tx, ty)                    r = r + (er * ditherMatrix[i][3])                    g = g + (eg * ditherMatrix[i][3])                    b = b + (eb * ditherMatrix[i][3])                    data:setPixel(tx, ty, r, g, b, 1)                end            end        end    end    -- uncomment to print the palette string to the console    -- print(palStr)    return love.graphics.newImage(data)endfunction love.draw()    -- draw original image    love.graphics.draw(originalImg, 0, 0, 0, scale, scale)    -- draw dithered image    love.graphics.draw(transformedImg, 768, 0, 0, scale, scale)end</code></pre></div><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=257841">Trystan</a> — Tue Feb 27, 2024 9:59 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[nSun]]></name></author>
		<updated>2023-11-21T14:15:15+00:00</updated>

		<published>2023-11-21T14:15:15+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=257604#p257604</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=257604#p257604"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=257604#p257604"><![CDATA[
I'm a beginner with Löve, and working on my first project (to test) based on this topic.<br>Particularly on <strong class="text-strong">Error-diffusion</strong> dithering algorithms:<br>Floyd–Steinberg, Jarvis, Judice &amp; Ninke, Stucki, Burkes, Sierra, Two-row Sierra, Sierra Lite, Atkinson...<br><br><a href="https://en.wikipedia.org/wiki/Dither#Algorithms" class="postlink">https://en.wikipedia.org/wiki/Dither#Algorithms</a><br><br><div class="inline-attachment"><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=23770&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=23770" class="postimage" alt="love-dithering-tests.png" /></a></dt></dl></div><br>Just drop your file/picture in the window then keypress numpad :<br>0: Gray scale<br>1: Atkinson<br>2: Floyd-Steinberg<br>3: Jarvis, Judice, and Ninke Dithering<br>4: Stucki<br>5: Burkes<br>6: Sierra<br>7: Sierra 2 rows<br>8: Sierra Lite<br>9: none (original)<br><br>I use a "sensitive" grayscale :<div class="codebox"><p>Code: </p><pre><code>local red, green, blue, alpha = self.data:getPixel( x, y )-- logical grayscale -- color = (red + green + blue) /3-- sensitive grayscale color = 0.3 * red + 0.59 * green + 0.11 * blue</code></pre></div>Because a "logical" gray scale produces a darker image. But to the eye, a 100% red appears darker than a 100% green.<br><br><br>I used a class that I had coded in PHP/CLI tool, excuse me if it's not clean...<dl class="file"><dt><span class="imageset icon_topic_attach"></span> <a class="postlink" href="https://love2d.org/forums/download/file.php?id=23771">classic.lua</a></dt></dl><br /><dl class="file"><dt><span class="imageset icon_topic_attach"></span> <a class="postlink" href="https://love2d.org/forums/download/file.php?id=23772">dithering.lua</a></dt></dl><br /><dl class="file"><dt><span class="imageset icon_topic_attach"></span> <a class="postlink" href="https://love2d.org/forums/download/file.php?id=23773">main.lua</a></dt></dl><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=257786">nSun</a> — Tue Nov 21, 2023 2:15 pm</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[tourgen]]></name></author>
		<updated>2023-05-04T19:31:08+00:00</updated>

		<published>2023-05-04T19:31:08+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=254691#p254691</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=254691#p254691"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=254691#p254691"><![CDATA[
great work! I'm probably going to use this.. or something similar. I want an CGA and EGA mode for my little text adventure. now it has some still gfx... AI generated<p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=219420">tourgen</a> — Thu May 04, 2023 7:31 pm</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[darkfrei]]></name></author>
		<updated>2023-04-28T07:10:59+00:00</updated>

		<published>2023-04-28T07:10:59+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=254551#p254551</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=254551#p254551"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=254551#p254551"><![CDATA[
The gradient can be much smooth:<br><div class="codebox"><p>Code: </p><pre><code>function projectPointOnLineSegment(aX, aY, aZ, bX, bY, bZ, cX, cY, cZ)    local dx, dy, dz = bX - aX, bY - aY, bZ - aZ    local len2 = (dx*dx + dy*dy + dz*dz)if len2 == 0 thenreturn 0end    local dot = (cX - aX)*dx + (cY - aY)*dy + (cZ - aZ)*dz    local t = dot / len2^0.5-- https://www.desmos.com/calculator/gnq3hm26t0--t = 4*(t-0.5)^3 + 0.5t = -8*(t-0.5)^4+0.5if t &gt; 0.5 thenprint (t)end    return tend</code></pre></div><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=23270&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=23270" class="postimage" alt="2023-04-28-palette 125 (4 colors).png" /></a></dt></dl><br /><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=23269&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=23269" class="postimage" alt="2023-04-28-palette 152 (10 colors).png" /></a></dt></dl><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=145963">darkfrei</a> — Fri Apr 28, 2023 7:10 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[darkfrei]]></name></author>
		<updated>2023-04-28T06:50:48+00:00</updated>

		<published>2023-04-28T06:50:48+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=254550#p254550</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=254550#p254550"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=254550#p254550"><![CDATA[
The color dithering.<br><br>1. Find 2 nearest palette colors (point 1 and point 2) in 3D space to the current pixel color:<div class="codebox"><p>Code: </p><pre><code>function nearestColorIndex(r, g, b, palette)local firstIndex = 1local secondIndex = 1local min1 = math.hugelocal min2 = math.hugefor index, color in ipairs(palette) dolocal dr = r - color[1]local dg = g - color[2]local db = b - color[3]local value = dr*dr + dg*dg + db*dbif value &lt; min1 thenmin2 = min1min1 = valuesecondIndex = firstIndexfirstIndex = indexelseif value &lt; min2 thensecondIndex = indexmin2 = valueendendreturn firstIndex, secondIndexend</code></pre></div>2. Make the line between this two palette colors.<br>3. Project the current color point to this line and get the value t, that changes from 0 to 1 and represents x=x1+t*(x2-x1); y=y1+t*(y2-y1); z=z1+t*(z2-z1):<div class="codebox"><p>Code: </p><pre><code>function projectPointOnLineSegment(aX, aY, aZ, bX, bY, bZ, cX, cY, cZ)    local dx, dy, dz = bX - aX, bY - aY, bZ - aZ    local len2 = (dx*dx + dy*dy + dz*dz)if len2 == 0 thenreturn 0end    local dot = (cX - aX)*dx + (cY - aY)*dy + (cZ - aZ)*dz    local t = dot / len2^0.5    return tend</code></pre></div>Use this t as comparing value to the matrix:<div class="codebox"><p>Code: </p><pre><code>local ditherMatrix = {{0, 7, 3},{6, 5, 2},{4, 1, 8}}</code></pre></div>4. Draw color 1 if the value is lower or color 2 if not.<br><div class="codebox"><p>Code: </p><pre><code>-- License CC0 (Creative Commons license) (c) darkfrei, 2023local imageName = 'lenna-512.png'--local imageName = 'ball.png'local palettes = {}local i = 0for line in love.filesystem.lines("palettes.txt") doi = i + 1local palette = loadstring ("return " .. line)()table.insert (palettes, palette)endpaletteID = 129palette = palettes[paletteID]local lennaPalette = {{206/255,95/255,93/255},{230/255,133/255,128/255},{222/255,106/255,99/255},{195/255,127/255,120/255},{231/255,198/255,199/255},{96/255,23/255,62/255},{138/255,96/255,150/255},{227/255,93/255,105/255},{241/255,204/255,190/255},{237/255,182/255,167/255},}table.insert (palettes, lennaPalette)local nPal = {}for r = 0, 3 dofor g = 0, 3 dofor b = 0, 3 dotable.insert (nPal, {r/3, g/3, b/3})endendendpalettes[128] = nPalnPal = {}for r = 0, 2 dofor g = 0, 2 dofor b = 0, 2 dotable.insert (nPal, {r/2, g/2, b/2})endendendpalettes[130] = nPalpalettes[131] = {{0,0,0}, {1,1,1}}palettes[132] = {{0,0,0}, {0.5,0.5,0.5}, {1,1,1}}palettes[133] = {{211/255, 219/255, 233/255}, {129/255, 154/255, 193/255}, {18/255,64/255, 138/255}, {153/255,123/255, 75/255}}paletteID = 124palette = palettes[paletteID]love.window.setTitle ('palette ' .. paletteID .. ' ('..#palette..' colors)')function nearestColorIndex(r, g, b, palette)local firstIndex = 1local secondIndex = 1local min1 = math.hugelocal min2 = math.hugefor index, color in ipairs(palette) dolocal dr = r - color[1]local dg = g - color[2]local db = b - color[3]local value = dr*dr + dg*dg + db*dbif value &lt; min1 thenmin2 = min1min1 = valuesecondIndex = firstIndexfirstIndex = indexelseif value &lt; min2 thensecondIndex = indexmin2 = valueendendreturn firstIndex, secondIndexendlocal ditherMatrix = {{0, 7, 3},{6, 5, 2},{4, 1, 8}}function projectPointOnLineSegment(aX, aY, aZ, bX, bY, bZ, cX, cY, cZ)    local dx, dy, dz = bX - aX, bY - aY, bZ - aZ    local len2 = (dx*dx + dy*dy + dz*dz)if len2 == 0 thenreturn 0end    local dot = (cX - aX)*dx + (cY - aY)*dy + (cZ - aZ)*dz    local t = dot / len2^0.5    return tendfunction getValue (x, y)local r, g, b = 0, 0, 0if x &lt; imageData:getWidth() and y &lt; imageData:getHeight()and x &gt; 0 and y &gt; 0 thenr, g, b = imageData:getPixel(x-1, y-1)endlocal firstIndex, secondIndex = nearestColorIndex(r, g, b, palette)local first, second= palette[firstIndex], palette[secondIndex]local ditherValue = ditherMatrix[(y-1)%3+1][(x-1)%3+1]local compareValue = -0.25+4.5*projectPointOnLineSegment(first[1], first[2], first[3], second[1], second[2], second[3], r,g,b)if firstIndex &lt; secondIndex  then-- magic!ditherValue = 4-(ditherValue -4)endif (ditherValue &gt; compareValue) thenr, g, b = first[1], first[2], first[3]elser, g, b = second[1], second[2], second[3]endreturn r, g, b, ditherValue, compareValueendfunction dither3x3(path, palette)imageData = love.image.newImageData(path)local width, height = imageData:getDimensions()for y = 1, height dofor x = 1, width dolocal r, g, b = getValue (x, y)imageData:setPixel(x-1, y-1, r,g,b)endendreturn love.graphics.newImage(imageData)endfunction love.load()Image = dither3x3(imageName, palette)Image2 = love.graphics.newImage(imageName)Width = Image2:getWidth()love.window.setMode(Width*2, Image2:getHeight())endfunction love.draw()love.graphics.setColor (1,1,1)love.graphics.draw (Image2)love.graphics.draw (Image, Width, 0)love.graphics.print ('press SPACE to change palette')endfunction love.keypressed(key, scancode, isrepeat)if key == "space" thenpaletteID = paletteID + 1if paletteID &gt; #palettes then paletteID = 1 endpalette = palettes[paletteID]love.window.setTitle ('palette ' .. paletteID .. ' ('..#palette..' colors)')Image = dither3x3(imageName, palette)elseif key == "escape" thenlove.event.quit()endend</code></pre></div><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=23268&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=23268" class="postimage" alt="2023-04-27T15_22_42-palette 133 (4 colors).png" /></a></dt></dl><br /><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=23267&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=23267" class="postimage" alt="2023-04-28T08_38_55-palette 131 (2 colors).png" /></a></dt></dl><br /><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=23266&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=23266" class="postimage" alt="palette-dithering-03.png" /></a></dt></dl><br /><dl class="file"><dt><img src="./images/upload_icons/love.png" alt="" /> <a class="postlink" href="https://love2d.org/forums/download/file.php?id=23265">palette-dithering-03.love</a></dt></dl><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=145963">darkfrei</a> — Fri Apr 28, 2023 6:50 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[Bigfoot71]]></name></author>
		<updated>2023-03-10T22:58:47+00:00</updated>

		<published>2023-03-10T22:58:47+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=253834#p253834</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=253834#p253834"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=253834#p253834"><![CDATA[
Super cool, I love it!<br><br>Small suggestion, there is the mapPixel function to do this more efficiently, I slightly rewrote the function for this:<div class="codebox"><p>Code: </p><pre><code>-- dithering matrix 3x3local matrix = {{ 230, 51, 128 },{ 25, 102,  179 },{ 154, 205, 77 },}local function dithering(data)local clone = data:clone()clone:mapPixel(function(x, y, r, g, b, a)local matrixValue = matrix[(y%3)+1][(x%3)+1]r = r*255 &gt;= matrixValue and 1 or 0g = g*255 &gt;= matrixValue and 1 or 0b = b*255 &gt;= matrixValue and 1 or 0return r, g, b, aend)local image = love.graphics.newImage(clone)clone:release()return imageendreturn dithering</code></pre></div><br><span style="text-decoration:underline">Edit</span>: I just made a small shader quickly, the effect is different but <strong class="text-strong">I love the rendering</strong>!<div class="codebox"><p>Code: </p><pre><code>extern float matrix[9];vec4 effect(vec4 color, Image tex, vec2 texCoords, vec2 screenCoords) {    vec4 pixel = Texel(tex, texCoords);    int x = int(mod(screenCoords.x, 3.0));    int y = int(mod(screenCoords.y, 3.0));    float matrixValue = matrix[x+y*3]/255.0;    float r = step(matrixValue, pixel.r);    float g = step(matrixValue, pixel.g);    float b = step(matrixValue, pixel.b);    return vec4(r, g, b, pixel.a);}</code></pre></div><img src="https://love2d.org/imgmirrur/XfUFdHb.png" class="postimage" alt="Image"><br><br>Here's how to have the same effect as the origin, you have to work on the coordinates of the texture <em class="text-italics">(uv*img_dimensions)</em> and not of the screen:<div class="codebox"><p>Code: </p><pre><code>extern float matrix[9];extern vec2 img_dim;vec4 effect(vec4 color, Image tex, vec2 texCoords, vec2 screenCoords) {    vec4 pixel = Texel(tex, texCoords);    int x = int(mod(texCoords.x*img_dim.x, 3.0));    int y = int(mod(texCoords.y*img_dim.y, 3.0));    float matrixValue = matrix[x+y*3]/255.0;    float r = step(matrixValue, pixel.r);    float g = step(matrixValue, pixel.g);    float b = step(matrixValue, pixel.b);    return vec4(r, g, b, pixel.a);}</code></pre></div><img src="https://love2d.org/imgmirrur/qTC7KnR.png" class="postimage" alt="Image"><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=188439">Bigfoot71</a> — Fri Mar 10, 2023 10:58 pm</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[dusoft]]></name></author>
		<updated>2023-03-08T11:11:32+00:00</updated>

		<published>2023-03-08T11:11:32+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=253788#p253788</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=253788#p253788"/>
		<title type="html"><![CDATA[Re: Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=253788#p253788"><![CDATA[
Nice!<p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=134239">dusoft</a> — Wed Mar 08, 2023 11:11 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[darkfrei]]></name></author>
		<updated>2023-03-08T09:33:36+00:00</updated>

		<published>2023-03-08T09:33:36+00:00</published>
		<id>https://love2d.org/forums/viewtopic.php?p=253787#p253787</id>
		<link href="https://love2d.org/forums/viewtopic.php?p=253787#p253787"/>
		<title type="html"><![CDATA[Dithering with matrix]]></title>

		
		<content type="html" xml:base="https://love2d.org/forums/viewtopic.php?p=253787#p253787"><![CDATA[
Hi all!<br><br>Here is a small tool to make dithering with matrix 3x3:<div class="codebox"><p>Code: </p><pre><code>-- dithering with matrix 3x3 pixelslocal function dithering(data)local width, height = data:getDimensions()local canvasImageData = love.image.newImageData(width, height)local matrix = {{ 230, 51, 128 },{ 25, 102, 179 },{ 154,205, 77  },}local sum = 0for i = 1, 10 dolocal v = 256/10 + (i-1)*256/10print (v)sum = sum + vendfor y = 0, height - 1 dofor x = 0, width - 1 dolocal r, g, b, a = love.math.colorToBytes(data:getPixel(x, y))local i, j = x%3+1, y%3+1local matrixValue = matrix[j][i]r = r &gt;= matrixValue and 1 or 0g = g &gt;= matrixValue and 1 or 0b = b &gt;= matrixValue and 1 or 0canvasImageData:setPixel(x, y, r, g, b, a)endendlocal canvas = love.graphics.newImage(canvasImageData)return canvasendreturn dithering</code></pre></div><div class="inline-attachment"><dl class="file"><dt class="attach-image"><a href="https://love2d.org/forums/download/file.php?id=22132&amp;mode=view"><img src="https://love2d.org/forums/download/file.php?id=22132" class="postimage" alt="2023-03-08-dithering.png" /></a></dt></dl></div><dl class="file"><dt><img src="./images/upload_icons/love.png" alt="" /> <a class="postlink" href="https://love2d.org/forums/download/file.php?id=22131">dithering-01.love</a></dt></dl><p>Statistics: Posted by <a href="https://love2d.org/forums/memberlist.php?mode=viewprofile&amp;u=145963">darkfrei</a> — Wed Mar 08, 2023 9:33 am</p><hr />
]]></content>
	</entry>
	</feed>
